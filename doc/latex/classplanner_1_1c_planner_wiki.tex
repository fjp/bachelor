\hypertarget{classplanner_1_1c_planner_wiki}{}\section{planner\+:\+:c\+Planner\+Wiki Class Reference}
\label{classplanner_1_1c_planner_wiki}\index{planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}}


Extends the planner class to implement A$\ast$ from Wikipedia.  




{\ttfamily \#include $<$planner\+\_\+wiki.\+h$>$}



Inheritance diagram for planner\+:\+:c\+Planner\+Wiki\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{classplanner_1_1c_planner_wiki__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for planner\+:\+:c\+Planner\+Wiki\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classplanner_1_1c_planner_wiki__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classplanner_1_1c_planner_wiki_aed6ae97e85a338e082ec2879629f0f3b}{c\+Planner\+Wiki}} (std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classplanner_1_1c_rover_interface}{c\+Rover\+Interface}}$<$ 8 $>$$>$ i\+\_\+po\+Rover, std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classplanner_1_1c_graph}{c\+Graph}} $>$ i\+\_\+o\+Map)
\begin{DoxyCompactList}\small\item\em Initializes member variables m\+\_\+po\+Rover and m\+\_\+o\+Map and calls \mbox{\hyperlink{classplanner_1_1c_planner_a2e5a745f83f903662eff914d8beddb5e}{Calculate\+Consistency\+Factor()}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classplanner_1_1c_planner_wiki_ab9f2b825a5b1e0bd2e33271f25c812be}\label{classplanner_1_1c_planner_wiki_ab9f2b825a5b1e0bd2e33271f25c812be}} 
\mbox{\hyperlink{classplanner_1_1c_planner_wiki_ab9f2b825a5b1e0bd2e33271f25c812be}{$\sim$c\+Planner\+Wiki}} ()
\begin{DoxyCompactList}\small\item\em Destructor to delete the allocated memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structt_result}{t\+Result}} \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a9d18be721400b51162ff463ab11d1721}{Plan}} () override
\begin{DoxyCompactList}\small\item\em Override of the base interface \mbox{\hyperlink{classplanner_1_1c_planner_interface}{c\+Planner\+Interface}}, which invokes the \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}{A\+Star()}} search algorithm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+Cost\+So\+Far , typename T\+Came\+From $>$ }\\void \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a049e5c4a9540fecbe82a0648f771bbd2}{Reconstruct\+Path}} (T\+Cost\+So\+Far \&\&i\+\_\+cost\+\_\+so\+\_\+far, T\+Came\+From \&\&i\+\_\+came\+\_\+from)
\begin{DoxyCompactList}\small\item\em Given the node i\+\_\+ps\+Node the overrides map m\+\_\+po\+Overrides is updated for displaying the path. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structt_result}{t\+Result}} \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}{A\+Star}} () override
\begin{DoxyCompactList}\small\item\em A\+Star algorithm implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Extends the planner class to implement A$\ast$ from Wikipedia. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classplanner_1_1c_planner_wiki_aed6ae97e85a338e082ec2879629f0f3b}\label{classplanner_1_1c_planner_wiki_aed6ae97e85a338e082ec2879629f0f3b}} 
\index{planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}!c\+Planner\+Wiki@{c\+Planner\+Wiki}}
\index{c\+Planner\+Wiki@{c\+Planner\+Wiki}!planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}}
\subsubsection{\texorpdfstring{c\+Planner\+Wiki()}{cPlannerWiki()}}
{\footnotesize\ttfamily planner\+::c\+Planner\+Wiki\+::c\+Planner\+Wiki (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classplanner_1_1c_rover_interface}{c\+Rover\+Interface}}$<$ 8 $>$$>$}]{i\+\_\+po\+Rover,  }\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classplanner_1_1c_graph}{c\+Graph}} $>$}]{i\+\_\+o\+Map }\end{DoxyParamCaption})}



Initializes member variables m\+\_\+po\+Rover and m\+\_\+o\+Map and calls \mbox{\hyperlink{classplanner_1_1c_planner_a2e5a745f83f903662eff914d8beddb5e}{Calculate\+Consistency\+Factor()}}. 

The 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}\label{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}} 
\index{planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}!A\+Star@{A\+Star}}
\index{A\+Star@{A\+Star}!planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}}
\subsubsection{\texorpdfstring{A\+Star()}{AStar()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structt_result}{t\+Result}} planner\+::c\+Planner\+Wiki\+::\+A\+Star (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



A\+Star algorithm implementation. 

Initializes start, goal and intermediate nodes (s\+Current and s\+Next). The frontier m\+\_\+o\+Frontier is implemented as a priority queue Priority\+Queue$<$t\+Node$\ast$$>$ and initialized with the start node. All other expanded nodes are store in a std\+::map o\+Path\+Cost with their currently best g score value. The algorithm makes use of \mbox{\hyperlink{classplanner_1_1c_planner_a6b7554394efd7ad10d76a49b370aa62f}{Goal\+Test()}}, \mbox{\hyperlink{classplanner_1_1c_planner_adbffc6ce05119c940a09369d7e61554e}{Child()}} to generate successor nodes given an action, Traversable to check for the constraints imposed by the overrides.\+data file, cost methods \mbox{\hyperlink{classplanner_1_1c_planner_a16e8c156297fff49a6ba9b97073baffb}{Update\+Cost()}} for the step cost, \mbox{\hyperlink{classplanner_1_1c_planner_ab7cc7c2666de2e49f745901080aac147}{Update\+Heuristic()}} while checking for consistency \mbox{\hyperlink{classplanner_1_1c_planner_a1234d075676fcaa2c17b859d11b4638c}{Heuristic\+Check()}}. In case the goal node is reached, the method \mbox{\hyperlink{classplanner_1_1c_planner_a8624cb2afb8f2fd216c38b4424013178}{Traverse\+Path()}} is invoked to move from the goal back to the start node, thereby following the fastest path and setting bit 1 of the overrides map, see \mbox{\hyperlink{classplanner_1_1c_graph_a6da6e6e269013628aef48245a7787cb9}{planner\+::c\+Graph\+::\+Set\+Overrides()}}. \begin{DoxyReturn}{Returns}
the time it took to find the fastest path in island seconds. 
\end{DoxyReturn}
The set of nodes already evaluated. Implemented as 2d array filled with 0s and start element set to 1.

The set of currently discovered nodes that are not evaluated yet. Initially, only the start node is known. ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 Defined the simplified start node

For each node, which action it can most efficiently be reached from. If a node can be reached from many nodes, action will eventually contain the most efficient previous step. ~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
~\newline
 For each node, the cost of getting from the start node to that node.

The cost of going from start to start is zero.

Initialize result struct

While the goal is not found the problem is solvable

Resign if no values in the open list and you can\textquotesingle{}t expand anymore

Remove the node from the open priority queue having the lowest f\+Score value

Check if the goal is reached

Otherwise explore new locations

Add the current node to the set of nodes already evaluated

Perform each possible rover action on the current node

Check if the location of the next node lies within the map and is not on water. Ignore the neighbors which are already evaluated (closed\mbox{[}n\+X\+Next\mbox{]}\mbox{[}n\+Y\+Next\mbox{]} == 0). ~\newline
~\newline
~\newline
~\newline
 The distance from start to a neighbor

Mark visited nodes

Check that heuristic never overestimates the true distance\+: Priority of a new node should never be lower than the priority of its parent. ~\newline
 Move from the current node back to the start node

Define start node

Create hash of the node using its position

Get the goal node

Create current node

Serves as explored (closed) set and cost to reach a node

Initialize start node with cost of zero because it does not cost anything to go to it

Initialize result struct

Resign if the frontier is empty, which means there are no nodes to expand and the goal has not been found

Check if the node is already explored and if its path cost got smaller (found a better path to it).

Check if the heuristic of the node is consistent h(n) $<$= c(p,n) + h(p).

Update the evaluation score value and put it on the frontier.

Mark visited nodes

Check that heuristic never overestimates the true distance\+: Priority of a new node should never be lower than the priority of its parent. ~\newline
~\newline
 Move from the current node back to the start node

Free memory 

Reimplemented from \mbox{\hyperlink{classplanner_1_1c_planner_a341e70531266f023ac9461d18979d1ef}{planner\+::c\+Planner}}.

\mbox{\Hypertarget{classplanner_1_1c_planner_wiki_a9d18be721400b51162ff463ab11d1721}\label{classplanner_1_1c_planner_wiki_a9d18be721400b51162ff463ab11d1721}} 
\index{planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}!Plan@{Plan}}
\index{Plan@{Plan}!planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}}
\subsubsection{\texorpdfstring{Plan()}{Plan()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structt_result}{t\+Result}} planner\+::c\+Planner\+Wiki\+::\+Plan (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Override of the base interface \mbox{\hyperlink{classplanner_1_1c_planner_interface}{c\+Planner\+Interface}}, which invokes the \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}{A\+Star()}} search algorithm. 

\begin{DoxyReturn}{Returns}
the time to travel from start to goal if it was found. Otherwise -\/1 is returned. 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{classplanner_1_1c_planner_a21230c015260b9fc34ad2f239592470e}{planner\+::c\+Planner}}.

\mbox{\Hypertarget{classplanner_1_1c_planner_wiki_a049e5c4a9540fecbe82a0648f771bbd2}\label{classplanner_1_1c_planner_wiki_a049e5c4a9540fecbe82a0648f771bbd2}} 
\index{planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}!Reconstruct\+Path@{Reconstruct\+Path}}
\index{Reconstruct\+Path@{Reconstruct\+Path}!planner\+::c\+Planner\+Wiki@{planner\+::c\+Planner\+Wiki}}
\subsubsection{\texorpdfstring{Reconstruct\+Path()}{ReconstructPath()}}
{\footnotesize\ttfamily template$<$typename T\+Cost\+So\+Far , typename T\+Came\+From $>$ \\
void planner\+::c\+Planner\+Wiki\+::\+Reconstruct\+Path (\begin{DoxyParamCaption}\item[{T\+Cost\+So\+Far \&\&}]{i\+\_\+cost\+\_\+so\+\_\+far,  }\item[{T\+Came\+From \&\&}]{i\+\_\+came\+\_\+from }\end{DoxyParamCaption})}



Given the node i\+\_\+ps\+Node the overrides map m\+\_\+po\+Overrides is updated for displaying the path. 

Traversing a path takes place using the m\+\_\+ps\+Parent field of the \mbox{\hyperlink{structplanner_1_1t_node}{t\+Node}} struct. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em i\+\_\+ps\+Node} & Goal node or any other which is traversed back \\
\hline
\end{DoxyParams}
Set the cost (time) it takes to get to the goal

Reconstruct the path by going backward

Update cumulative elevation

Store path in overrides

Check if the current node is the start node

Move towards the start

Update cumulative elevation

Store path in overrides 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/fjp/git/bachelor/planner/include/planner\+\_\+wiki.\+h\item 
/\+Users/fjp/git/bachelor/planner/src/planner\+\_\+wiki.\+cpp\end{DoxyCompactItemize}
