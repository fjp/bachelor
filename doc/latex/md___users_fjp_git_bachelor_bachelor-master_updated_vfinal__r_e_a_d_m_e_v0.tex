This is my solution for the A\+ID Bachelor Coding Challenge. For the problem description refer to the \href{AID_Coding_Challenge.pdf}{\tt A\+ID Coding Challenge.\+pdf}. The complete doxygen documentation can be found in the doc folder, see \href{doc/html/index.html}{\tt index.\+html}

\section*{Result Preview}

Travelling from the Rover (R\+O\+V\+E\+R\+\_\+X, R\+O\+V\+E\+R\+\_\+Y) to the Bachelor (B\+A\+C\+H\+E\+L\+O\+R\+\_\+X, B\+A\+C\+H\+E\+L\+O\+R\+\_\+Y) will take 2094.\+51 island seconds (34.\+9085 island minutes or 0.\+581809 island hours) on the fastest path.

Travelling from the Bachelor (B\+A\+C\+H\+E\+L\+O\+R\+\_\+X, B\+A\+C\+H\+E\+L\+O\+R\+\_\+Y) to the Wedding (W\+E\+D\+D\+I\+N\+G\+\_\+X, W\+E\+D\+D\+I\+N\+G\+\_\+Y) will take 1283.\+17 island seconds (21.\+3862 island minutes or 0.\+356436 island hours) on the fastest path.

In total the Audi rover requires 3377.\+68 island seconds (56.\+2947 island minutes or 0.\+938245 island hours) on the fastest path. Details are explained at the end in section Results. To plot the path I added another path() function to the visualizer.\+cpp.

image html solution\+\_\+rover\+\_\+bachelor\+\_\+wedding.\+jpg





\section*{Algorithm Choice}

To find the fastest route from a start to a goal location, I considered Gradient Fields, Dynamic Programming and Graph Search algorithms. I decided to use A$\ast$ graph search because it is an informed search algorithm, which uses a heuristic function $h(n)$ and relies on dynamic programming to find the shortest path. Compared to Dijkstra, which is an uninformed algorithm. The heuristic provides A$\ast$ ~\newline
 with an estimate of the minimum cost from any node n to the goal.

Another reason against Gradient descent are the non-\/convex constraints imposed by the fjords. Gradient descent could easily fall into a lokal minimum and get stuck, which would require methods such as stochastic gradient descent.

\subsection*{Cost Function}

The evaluation function $f(n) = g(n) + h(n)$ describes the total cost of a node. It consists of the path cost $g(n)$, which describes how long it takes the rover to get to node $n$ from its start location.

The path cost $g(n)$ is calculated using the parent node\textquotesingle{}s path cost $g(parent)$ and the step cost $c(n)$, which is the cost of getting from the parent to the current node and that has to be positive. The step cost is described in the next section step-\/cost.

In this challenge the heuristic represents the time it takes the robot to move from a node to the goal. Because the robot can move in eight directions (straight and diagonal) I use an octile distance heuristic $h(n)$, implemented in c\+Planner\+::\+Update\+Heuristic(). To get a consistent heuristic, I scaled it using the maximum gradient analyzing the elevation of the map and taking the slope into account. The consistency $ h(n) <= c(n,p) + h(p)$ is checked in \mbox{\hyperlink{classplanner_1_1c_planner_a1234d075676fcaa2c17b859d11b4638c}{planner\+::c\+Planner\+::\+Heuristic\+Check()}}. I exported the calculated heuristic values using \mbox{\hyperlink{classplanner_1_1c_planner_a1a4650050656545744796296a653d388}{planner\+::c\+Planner\+::\+Generate\+Heuristic()}} in the google test T\+E\+S\+T\+\_\+\+F(c\+Planner\+Test, heuristic) (see, test\+\_\+system.\+cpp).

image html heuristic.\+jpg



\subsection*{Step Cost Model}

Another task was to model the speed of the rover when driving up or downhill. For this purpose I implemented a simple kinematic approach with an inclined plane to model the elevation of the terrain.

image html inclined.\+jpg

 

The first step is to calculate the descent or ascent using the height difference between two locations, see \mbox{\hyperlink{classplanner_1_1c_planner_a16e8c156297fff49a6ba9b97073baffb}{planner\+::c\+Planner\+::\+Update\+Cost()}}. In this method the pitch angle is calculated next, followed by computing the x or y component of the downhill-\/slope force using the gravitational force $F_G$. In the equation the friction is neglected.

\begin{eqnarray*} F_H &= F_G \cdot sin\alpha \\ a_H &= g \cdot sin\alpha \\ F_{H,x} &= F_H \cdot cos\alpha \\ F_{H,x} = F_H \cdot cos\alpha \cdot sin\alpha = F_G \cdot \frac{1}{2} sin(2\alpha) \\ m \cdot a_x = m \cdot g \cdot \frac{1}{2} sin(2\alpha) \end{eqnarray*}

While the rover is moving up or downhill it is also moving in the x or y direction and the calculated acceleration $a_x$ in x direction is acting on the rover. The same equation holds for the y-\/direction. To get the time it takes the rover to move up or downhill (regarding the two dimensional plane), the planar acceleration is used in the next kinematic equation, where $\Delta s$ refers to the running length in either x or y direction.

\begin{eqnarray*} \Delta s &= v_0 \cdot t + \frac{1}{2} a_x t^2 \\ \Delta s &= \frac{g}{4} \cdot sin(2\alpha) \cdot t^2 \\ t &= \sqrt(\frac{4 \Delta s}{g \cdot sin(2\alpha}) \end{eqnarray*}

The start velocity is neglected in this formula but added to the final height time cost. The time it takes the rover to move one cell is given in the problem description (1 island second moving straight, and $\sqrt 2$ moving diagonal). These step costs are implemented in \mbox{\hyperlink{classplanner_1_1c_planner_a16e8c156297fff49a6ba9b97073baffb}{planner\+::c\+Planner\+::\+Update\+Cost()}}.

\section*{Time and Space Complexity}

I avoid allocating two dimensional vectors of the image size. Instead I am using a std\+::priority\+\_\+queue priority\+\_\+queue.\+h (planner\+::c\+Planner\+::m\+\_\+po\+Frontier) and a std\+::map. The priority queue is sorted by the score value of the evaluation function $f(n)$ and contains the frontier or border nodes. All expanded nodes are stored in an std\+::map inside the \mbox{\hyperlink{classplanner_1_1c_planner_a341e70531266f023ac9461d18979d1ef}{planner\+::c\+Planner\+::\+A\+Star()}} method together with their path costs $g(n)$.

The priority queue is suggested in all the literature and can access elements in linear time. With a step size of one the algorithm requires approximately 2 minutes to find the best path from rover to bachelor to the wedding. (Mac\+Book Pro 3,3 G\+Hz Intel Core i7, 16 GB 2133 M\+Hz L\+P\+D\+D\+R3).

\section*{Software Organization and Architecture}

The advantage of using interfaces is to get different implementations with different behavior but keep the public interface methods the same. I use two interfaces that have a reference to each other, \mbox{\hyperlink{classplanner_1_1c_rover_interface}{planner\+::c\+Rover\+Interface}} and \mbox{\hyperlink{classplanner_1_1c_planner_interface}{planner\+::c\+Planner\+Interface}}. The \mbox{\hyperlink{classplanner_1_1c_audi_rover}{planner\+::c\+Audi\+Rover}} implements \mbox{\hyperlink{classplanner_1_1c_rover_interface}{planner\+::c\+Rover\+Interface}} and acts as a factory, creating \mbox{\hyperlink{classplanner_1_1c_planner}{planner\+::c\+Planner}} in planner\+::c\+Rover\+Interface\+::\+Initialize\+Planner(). To construct a Rover it requires the map data ({\ttfamily elevation.\+data} and
\begin{DoxyCode}
overrides 
\end{DoxyCode}
). This data is used int the constructor of \mbox{\hyperlink{classplanner_1_1c_audi_rover}{planner\+::c\+Audi\+Rover}} to create a new map data structure of type t\+Graph. In the constructor the array of actions is initizlized which is flexible due to the template parameter of the base class planner\+::c\+Rover\+Interface$<$size\+\_\+t Directions$>$. To start planning, the start and goal positions of the rover need to be set with planner\+::c\+Rover\+Interface\+::\+Set\+Start() and planner\+::c\+Rover\+Interface\+::\+Set\+Goal(). These methods provide the rover with location structs of type t\+Location. After the initialization, a call to the method \mbox{\hyperlink{classplanner_1_1c_audi_rover_a09a9f9ff21d3b139db7c2990a5989674}{planner\+::c\+Audi\+Rover\+::\+Summon()}}, invokes the method \mbox{\hyperlink{classplanner_1_1c_audi_rover_a892dfcdf781ccdfe95f5af808f5a24ac}{planner\+::c\+Audi\+Rover\+::\+Initialize\+Planner()}} which is part of the interface and used to create a new planner object. Finally the the interface method \mbox{\hyperlink{classplanner_1_1c_planner_interface_a7a06632a8c53906daf39611d9692ffa5}{planner\+::c\+Planner\+Interface\+::\+Plan()}} is called. Possible parameters to \mbox{\hyperlink{classplanner_1_1c_audi_rover_a09a9f9ff21d3b139db7c2990a5989674}{planner\+::c\+Audi\+Rover\+::\+Summon()}} are the step size \mbox{\hyperlink{classplanner_1_1c_rover_interface_aea86540c3962e223de84f28ff067d788}{planner\+::c\+Rover\+Interface\+::m\+\_\+n\+Step\+Size}} and its velocity \mbox{\hyperlink{classplanner_1_1c_rover_interface_a458f3e469a13cfc909e957678ddee753}{planner\+::c\+Rover\+Interface\+::m\+\_\+n\+Velocity}} (not tested testing).

During the the while loop of the A\+Star() method, debug messages are displayed every 100000 iterations in the following form\+:


\begin{DoxyCode}
Max gradient 8
Iteration 100000: Best node location (1406,338), 
     Evaluation function f(n): 423.181, step cost c(n): 0.654846, path cost g(n): 320.498, heuristic h(n):
       102.683
Iteration 200000: Best node location (1299,592), 
     Evaluation function f(n): 654.874, step cost c(n): 2.17358, path cost g(n): 573.159, heuristic h(n):
       81.7151
Iteration 300000: Best node location (1330,782), 
     Evaluation function f(n): 831.174, step cost c(n): 1, path cost g(n): 769.743, heuristic h(n): 61.4311
Iteration 400000: Best node location (1565,567), 
     Evaluation function f(n): 917.657, step cost c(n): 1.41418, path cost g(n): 844.46, heuristic h(n):
       73.1971
\end{DoxyCode}


\subsection*{C\+Make and File Structure}

I added a new planner library which gets linked by the main program Bachelor. To get the visualization working during the algorithm I placed the functions inside the main.\+cpp inside utilities.\+h and constants.\+h. The content of other files is documented in the Doxygen documentation. ~\newline


\section*{Coding Style}

For the variable naming conventions, I follow the \href{https://en.wikipedia.org/wiki/MISRA_C}{\tt M\+I\+S\+RA C} standard.

\section*{Testing}

{\bfseries Note} The tests are not completely finished because of the limited time.

I added google g\+Test version 1.\+8.\+0 to the zip file and created a test fixture \mbox{\hyperlink{classc_planner_test}{c\+Planner\+Test}} in test\+\_\+fixture.\+h. It is used to initialize the test by loading the evaluation.\+data and overrides.\+data files. Furthermore, the c\+Audi\+Rover is initialized in the c\+Planner\+Test\+::\+Set\+Up method.

As explained in software the default values for step size and velocity are set to one for both parameters. I tested with different step sizes to reach the goal faster, thereby verifying that the path and island seconds stay the same.

To get intermediate paths from the \mbox{\hyperlink{classplanner_1_1c_planner_a341e70531266f023ac9461d18979d1ef}{planner\+::c\+Planner\+::\+A\+Star()}} I used the provided \mbox{\hyperlink{namespacevisualizer_ab4e649cd7413a51ac1ae4b31a2994c3a}{visualizer\+::write\+B\+M\+P()}} inside A\+Star(). This results in the following output\+:

\subsection*{Results}

The total travelling time will take 3377.\+68 island seconds (56.\+2947 island minutes or 0.\+938245 island hours) on the fastest path. Hopefully this is enough for the Bachelor to get to his wedding on time.

image html solution\+\_\+rover\+\_\+bachelor\+\_\+wedding.\+jpg



The best path avoids high mountains and even gets close to see locations (bachelor to wedding) to find the fastest route.


\begin{DoxyCode}
Max gradient: 8, Consistency factor: 10
Iteration 100000: Best node location (334,1646), 
     Evaluation function f(n): 455.802, step cost c(n): 1.63855, path cost g(n): 259.565, heuristic h(n):
       196.237
Iteration 200000: Best node location (413,1697), 
     Evaluation function f(n): 582.518, step cost c(n): 1.63855, path cost g(n): 384.453, heuristic h(n):
       198.065
Iteration 300000: Best node location (495,1121), 
     Evaluation function f(n): 741.235, step cost c(n): 1.40002, path cost g(n): 604.166, heuristic h(n):
       137.068
Iteration 400000: Best node location (222,996), 
     Evaluation function f(n): 815.994, step cost c(n): 1.40002, path cost g(n): 670.159, heuristic h(n):
       145.835
Iteration 500000: Best node location (426,904), 
     Evaluation function f(n): 863.824, step cost c(n): 1.40002, path cost g(n): 742.2, heuristic h(n):
       121.624
Iteration 600000: Best node location (693,1925), 
     Evaluation function f(n): 923.431, step cost c(n): 1, path cost g(n): 714.164, heuristic h(n): 209.267
Iteration 700000: Best node location (733,1933), 
     Evaluation function f(n): 1015.57, step cost c(n): 1, path cost g(n): 807.162, heuristic h(n): 208.41
Iteration 800000: Best node location (877,1969), 
     Evaluation function f(n): 1095.94, step cost c(n): 1.40002, path cost g(n): 889.893, heuristic h(n):
       206.046
Iteration 900000: Best node location (747,840), 
     Evaluation function f(n): 1178.13, step cost c(n): 1.40002, path cost g(n): 1079.6, heuristic h(n):
       98.5303
Iteration 1000000: Best node location (868,1036), 
     Evaluation function f(n): 1290.78, step cost c(n): 2.15552, path cost g(n): 1177.67, heuristic h(n):
       113.118
Iteration 1100000: Best node location (837,623), 
     Evaluation function f(n): 1370.08, step cost c(n): 1, path cost g(n): 1296.97, heuristic h(n): 73.1023
Iteration 1200000: Best node location (1023,906), 
     Evaluation function f(n): 1426.84, step cost c(n): 0.644409, path cost g(n): 1333.14, heuristic h(n):
       93.698
Iteration 1300000: Best node location (1060,512), 
     Evaluation function f(n): 1473.57, step cost c(n): 2.37537, path cost g(n): 1420.8, heuristic h(n):
       52.7654
Iteration 1400000: Best node location (819,1313), 
     Evaluation function f(n): 1518.79, step cost c(n): 1, path cost g(n): 1375.94, heuristic h(n): 142.848
Iteration 1500000: Best node location (1141,719), 
     Evaluation function f(n): 1559.78, step cost c(n): 2.24475, path cost g(n): 1489.67, heuristic h(n):
       70.1103
Iteration 1600000: Best node location (943,329), 
     Evaluation function f(n): 1593.74, step cost c(n): 2.15552, path cost g(n): 1547.64, heuristic h(n):
       46.1068
Iteration 1700000: Best node location (936,273), 
     Evaluation function f(n): 1631.22, step cost c(n): 1, path cost g(n): 1586.74, heuristic h(n): 44.4872
Iteration 1800000: Best node location (1326,1140), 
     Evaluation function f(n): 1669.75, step cost c(n): 2.15552, path cost g(n): 1563.3, heuristic h(n):
       106.453
Iteration 1900000: Best node location (1078,1322), 
     Evaluation function f(n): 1704.56, step cost c(n): 1, path cost g(n): 1571.54, heuristic h(n): 133.02
Iteration 2000000: Best node location (1053,1445), 
     Evaluation function f(n): 1738.76, step cost c(n): 1.63855, path cost g(n): 1592.4, heuristic h(n):
       146.355
Iteration 2100000: Best node location (974,96), 
     Evaluation function f(n): 1773.15, step cost c(n): 1.40002, path cost g(n): 1739.8, heuristic h(n):
       33.3556
Iteration 2200000: Best node location (1342,1376), 
     Evaluation function f(n): 1817.68, step cost c(n): 0.644409, path cost g(n): 1686.97, heuristic h(n):
       130.715
Iteration 2300000: Best node location (1421,397), 
     Evaluation function f(n): 1890.01, step cost c(n): 1.63855, path cost g(n): 1853.92, heuristic h(n):
       36.0877
Iteration 2400000: Best node location (1519,1058), 
     Evaluation function f(n): 1950.36, step cost c(n): 1, path cost g(n): 1844.11, heuristic h(n): 106.247
Iteration 2500000: Best node location (1398,265), 
     Evaluation function f(n): 2009.98, step cost c(n): 1.40002, path cost g(n): 1988.04, heuristic h(n):
       21.935
Iteration 2600000: Best node location (1379,182), 
     Evaluation function f(n): 2058.23, step cost c(n): 1, path cost g(n): 2045.38, heuristic h(n): 12.848
Travelling will take 2094.51 island seconds (34.9085 island minutes or 0.581809 island hours) on the
       fastest path. 
Max gradient: 8, Consistency factor: 10
Iteration 100000: Best node location (1416,333), 
     Evaluation function f(n): 422.513, step cost c(n): 0.64447, path cost g(n): 319.744, heuristic h(n):
       102.769
Iteration 200000: Best node location (1433,610), 
     Evaluation function f(n): 653.168, step cost c(n): 1.63855, path cost g(n): 578.803, heuristic h(n):
       74.3647
Iteration 300000: Best node location (1328,779), 
     Evaluation function f(n): 829.594, step cost c(n): 1.40002, path cost g(n): 767.78, heuristic h(n):
       61.8139
Iteration 400000: Best node location (1629,647), 
     Evaluation function f(n): 915.408, step cost c(n): 1.40002, path cost g(n): 848.555, heuristic h(n):
       66.8539
Iteration 500000: Best node location (1699,588), 
     Evaluation function f(n): 1000.31, step cost c(n): 1.40002, path cost g(n): 924.657, heuristic h(n):
       75.6534
Iteration 600000: Best node location (1512,1083), 
     Evaluation function f(n): 1079.1, step cost c(n): 1.40002, path cost g(n): 1055.3, heuristic h(n):
       23.7924
Iteration 700000: Best node location (1324,1112), 
     Evaluation function f(n): 1130.77, step cost c(n): 1, path cost g(n): 1097.93, heuristic h(n): 32.8387
Iteration 800000: Best node location (1759,1086), 
     Evaluation function f(n): 1179.28, step cost c(n): 1.40002, path cost g(n): 1150.94, heuristic h(n):
       28.3387
Heuristic not consistent: 61.3867 > 0.0733643 + 61.2453
Heuristic not consistent: 97.5835 > 0.0692139 + 97.4835
Iteration 900000: Best node location (1166,1154), 
     Evaluation function f(n): 1222.19, step cost c(n): 1, path cost g(n): 1175.29, heuristic h(n): 46.899
Iteration 1000000: Best node location (1222,1144), 
     Evaluation function f(n): 1262.49, step cost c(n): 1, path cost g(n): 1220.77, heuristic h(n): 41.7132
Travelling will take 1283.17 island seconds (21.3862 island minutes or 0.356436 island hours) on the
       fastest path. 

Travelling will take 3377.68 island seconds (56.2947 island minutes or 0.938245 island hours) on the
       fastest path.  
\end{DoxyCode}


Notice that the heuristic is not always consistent which requires more weight on the $g$ score values. This can also be seen from the f score value which should stay the same because it is the sum of $ g(n) + h(n) $. $g(n)$ should increase, while $h(n)$ should decrease when moving to the goal. Tuning could be done in \mbox{\hyperlink{classplanner_1_1c_planner_a2e5a745f83f903662eff914d8beddb5e}{planner\+::c\+Planner\+::\+Calculate\+Consistency\+Factor()}}, for example by lowering the gravitational force.

\subsection*{Intermediate Paths}

As described above here is the image showing the indermediate path results that were explored by A$\ast$.

image html intermediate\+\_\+rover\+\_\+bachelor\+\_\+wedding.\+bmp



\section*{References}

\begin{DoxyItemize}
\item Artificial Intelligence A Modern Approach Third Edition -\/ Stuart Russel, Peter Norvig \item Head First Design Patterns -\/ Eric Freeman, Elisabeth Robson \item \href{https://autonomous-driving.org/2018/08/15/so-you-want-to-be-a-self-driving-car-engineer/}{\tt https\+://autonomous-\/driving.\+org/2018/08/15/so-\/you-\/want-\/to-\/be-\/a-\/self-\/driving-\/car-\/engineer/} \item \href{https://www.linkedin.com/pulse/software-quality-sami-vaaraniemi/}{\tt https\+://www.\+linkedin.\+com/pulse/software-\/quality-\/sami-\/vaaraniemi/} \item \href{https://en.wikipedia.org/wiki/A}{\tt https\+://en.\+wikipedia.\+org/wiki/A}$\ast$\+\_\+search\+\_\+algorithm \item \href{https://en.wikipedia.org/wiki/Consistent_heuristic}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Consistent\+\_\+heuristic} \item \href{https://en.wikipedia.org/wiki/Admissible_heuristic}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Admissible\+\_\+heuristic} \item \href{https://www.redblobgames.com/pathfinding/a-star/introduction.html}{\tt https\+://www.\+redblobgames.\+com/pathfinding/a-\/star/introduction.\+html} \end{DoxyItemize}
