This is my updated solution for the A\+ID Bachelor Coding Challenge. The readme of the previous version can be found here. For the problem description refer to the \href{AID_Coding_Challenge.pdf}{\tt A\+ID Coding Challenge.\+pdf}. The complete doxygen documentation can be found in the doc folder, see \href{doc/html/index.html}{\tt index.\+html}

\subsection*{Result}

The figure below shows the optimal path with the following planning results\+:


\begin{DoxyCode}
Travelling will take 1322.29 island seconds (22.0381 island minutes or 0.367302 island hours) on the
       fastest path. 
Cumulative elevation: 42939
Number of expanded nodes: 315920
Heuristic is consistent
\end{DoxyCode}




\subsection*{Main New Features}

Beside the fixed bug of setting the diagonal cost to 1.\+4f instead of sqrt(2) I made the following changes to my solution.

\subsubsection*{Simplified Motion Model}

I simplified the step cost model of the rover. Instead of the physical model, used previously, the rover now uses height costs that are percentage values of the current step cost, which are either {\ttfamily 1} when moving straight or sqrt(2)\`{} when moving diagonal. The percentage step cost (height cost) is added to the current step cost if the rover moves uphill and subtracted if it moves downhill. This height cost calculation takes place in \mbox{\hyperlink{classplanner_1_1c_planner_a9d57a0697bb0e4666f4fd45f77c4a1aa}{planner\+::c\+Planner\+::\+Height\+Cost}}.

\subsubsection*{Consistent Heuristic}

A consistent heuristic is ensured with the chosen step cost and height cost model. This is achieved by calculating a normalization factor {\ttfamily m\+\_\+f\+Consistency\+Factor = 1.\+f -\/ static\+\_\+cast$<$double$>$(m\+\_\+n\+Max\+Gradient) / 255.\+0;}. I assume that {\ttfamily 255} is the maximum that the rover can climb or fall, which is why I divide by 255.\+0. The normalization factor is then used to normalize the calculated octile heuristic value in \mbox{\hyperlink{classplanner_1_1c_planner_a77cefeae3d7a58a96c74b66f6be22611}{planner\+::c\+Planner\+::\+Heuristic}}. To check the consistency of the heuristic during A$\ast$ I perform the check\+: h(x) $<$= d(x,y) + h(y) with x as parent node and y as its successor. In case of an inconsistent heuristic the boolean flag b\+Consistent\+Heuristic in the new member struct planner\+::t\+Result of c\+Planner\+Interface is set to false. This boolean flag is tested against in the g\+Tests.

\subsubsection*{Memory Leaks}

I analyzed my previous implementation using valgrind which showed memory leaks when creating child nodes in \mbox{\hyperlink{classplanner_1_1c_planner_adbffc6ce05119c940a09369d7e61554e}{planner\+::c\+Planner\+::\+Child}}. Additionally because of not destructing the planner and audi rover objects correctly. To overcome these memory leaks I now use smart pointers which are a C++11 feature. The valgrind results for the planner and g\+Test project are shown in \href{doc/valgrind.xml}{\tt doc/valgrind.\+xml} and \href{valgrind_gtest.xml}{\tt valgrind\+\_\+gtest.\+xml} respectively. See also the memory usage in the Memory Usage section below.

\subsubsection*{Implementation Correctness}

To verify the correctness of my implemented A\+Star algorithm, I added two more implementations.
\begin{DoxyEnumerate}
\item \href{https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode}{\tt Wikipedia A$\ast$ Pseudocode} implemented in class \mbox{\hyperlink{classplanner_1_1c_planner_wiki}{planner\+::c\+Planner\+Wiki}} which inherits from \mbox{\hyperlink{classplanner_1_1c_planner}{planner\+::c\+Planner}}.
\item \href{https://www.redblobgames.com/pathfinding/a-star/implementation.html#cplusplus}{\tt Red Blob Games A$\ast$} implemented in class \mbox{\hyperlink{classplanner_1_1c_planner_r_b_g}{planner\+::c\+Planner\+R\+BG}} which inherits from \mbox{\hyperlink{classplanner_1_1c_planner}{planner\+::c\+Planner}}.
\end{DoxyEnumerate}

Both use less memory than my previous implementation, which can still be found in \mbox{\hyperlink{classplanner_1_1c_planner_a341e70531266f023ac9461d18979d1ef}{planner\+::c\+Planner\+::\+A\+Star}}. Less memory usage is achieved with other data structures. For example the node struct in Red Blob Games implementation uses less fields (see planner\+::t\+Simplified\+Node). Regarding the computation time, \mbox{\hyperlink{classplanner_1_1c_planner_wiki_a2652cf0e84d0a1fcd17e6c4288179955}{planner\+::c\+Planner\+Wiki\+::\+A\+Star}} is the fastest implementation. Here preallocated vectors are used instead of a priority queue that needs to be updated in the other implementations.

\subsubsection*{g\+Tests using Simple Maps}

The mentioned implementations are used in new g\+Tests which create and use simple maps to test if the different implementations yield the same results (regarding travelling time given in island seconds). All test results are found in \href{doc/TestResults-testPlanner.html}{\tt doc/\+Test\+Results-\/test\+Planner.\+html}. Light red areas show the visited nodes, which is a new feature implemented in the lambda expression used in {\ttfamily \mbox{\hyperlink{namespacevisualizer_a2f66e38c689ff3c3731faa95739bbf25}{visualizer\+::write}}} function. The island map results for all three implementations are stored in \href{doc/images/test/}{\tt doc/images/test/}.


\begin{DoxyEnumerate}
\item simple\+\_\+map creates a 330x330 map with elevation 1 to check if the implementations find a path from the start to the goal location.
\end{DoxyEnumerate}




\begin{DoxyEnumerate}
\item simple\+\_\+map\+\_\+with\+\_\+water creates a 330x330 map with elevation 1 and water such that the greediness and therefore the heuristic is evaluated.
\end{DoxyEnumerate}



All the implementations find a shortest, passing the water obstacle.


\begin{DoxyEnumerate}
\item simple\+\_\+map\+\_\+with\+\_\+elevation is a 4x4 map with elevation 1 except the diagonal is set to 255. The rover needs to find a path between the left top corner (x,y)=(0,0) and the bottom right corner (x,y)=(3,3). This test is used to check the step cost, which is combination of height cost and direction cost. Furthermore, the consistency of the heuristic is evaluated.
\end{DoxyEnumerate}



Additional test results can be seen in the image folder \href{doc/images/test}{\tt doc/images/test}.

\subsection*{C++11 Features}

Used \href{https://github.com/AnthonyCalandra/modern-cpp-features}{\tt C++11 features}\+:
\begin{DoxyItemize}
\item smart pointer\+:
\begin{DoxyItemize}
\item \href{https://en.cppreference.com/w/cpp/memory/shared_ptr}{\tt std\+::shared\+\_\+ptr},
\item \href{https://en.cppreference.com/w/cpp/memory/weak_ptr}{\tt std\+::weak\+\_\+ptr},
\item \href{https://en.cppreference.com/w/cpp/memory/enable_shared_from_this}{\tt std\+::enable\+\_\+shared\+\_\+from\+\_\+this},
\item \href{https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this}{\tt shared\+\_\+from\+\_\+this()},
\item \href{https://en.cppreference.com/w/cpp/language/nullptr}{\tt nullptr}
\end{DoxyItemize}
\item \href{https://en.cppreference.com/w/cpp/language/lambda}{\tt Lambda expression}
\item \href{https://en.cppreference.com/w/cpp/language/list_initialization}{\tt List initialization}
\item \href{https://en.cppreference.com/w/cpp/language/reference}{\tt Rvalue reference}
\item \href{https://en.cppreference.com/w/cpp/utility/move}{\tt std\+::move}
\end{DoxyItemize}

\subsection*{Memory Usage}

The images below show the memory usage and runtime of the different A$\ast$ implementations.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ A\+Star  }&\textbf{ A\+Star Wikipedia  }&\textbf{ A\+Star Red Blob Games \+:-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---\+:   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ A\+Star  }&\textbf{ A\+Star Wikipedia  }&\textbf{ A\+Star Red Blob Games \+:-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---\+:   }\\\cline{1-3}
\endhead
  &  &   \\\cline{1-3}
270.\+5 MB, 4\+:30 min  &77.\+2 MB, 19.\+48 sec  &208.\+1 MB, 3 min   \\\cline{1-3}
\end{longtabu}


\subsection*{Class Design}

There exists a cyclic dependency between the rover interface and planner interface where the rover acts as a \href{https://en.wikipedia.org/wiki/Factory_method_pattern}{\tt factory} to create different planners.

The new implementations c\+Planner\+Wiki and c\+Planner\+R\+BG inherit c\+Planner which implements the interface.



\subsubsection*{Complete Changelog}


\begin{DoxyItemize}
\item Fixes diagonal cost value\+: uses sqrt(2) for the diagonal cost instead of 1.\+4f.
\item Fixes memory leaks caused by dangling pointers, mainly in the Child() method of planner.\+cpp.
\begin{DoxyItemize}
\item Valgrind shows no memory leaks anymore with the use of smart pointers (C++11 feature)
\item Now using smart pointers for the nodes
\item Uses \href{https://en.cppreference.com/w/cpp/memory/shared_ptr}{\tt shared\+\_\+ptr}, \href{http://en.cppreference.com/w/cpp/memory/weak_ptr}{\tt std\+::weak\+\_\+ptr}, \href{http://en.cppreference.com/w/cpp/memory/enable_shared_from_this}{\tt std\+::enable\+\_\+shared\+\_\+from\+\_\+this} and \href{https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this}{\tt shared\+\_\+from\+\_\+this()} for the cyclic dependency between rover interface and planner interface.
\item Use of smart pointers reduces memory consumption from approx 2 GB to 570 MB. This high memory is caused by creating child nodes while exploring new locations. Each node contains information that increase the memory used each time a new node is created.
\end{DoxyItemize}
\item Uses double instead of float for the cost values to improve numerical inaccuracy because of diagonal step cost sqrt(2).
\item To verify the correctness of the current implementation this version adds two more implementations of A$\ast$, one from \href{https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode}{\tt Wikipedia} and the other from \href{https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-astar}{\tt Red Blob Games}.
\item The new A$\ast$ implementations use less memory
\item Simplifies step cost model of the rover\+: instead of the physical model the rover now uses height costs that are percentage values of the step cost. The percentage step cost (height cost) is added to the current step cost if the rover moves uphill and subtracted if it moves downhill. The height cost calculation takes place in \mbox{\hyperlink{classplanner_1_1c_planner_a9d57a0697bb0e4666f4fd45f77c4a1aa}{planner\+::c\+Planner\+::\+Height\+Cost()}}.
\item Ensures consistent heuristic with the chosen step cost and height cost model. This is achieved by normalizing the calculated octile heuristic value in \mbox{\hyperlink{classplanner_1_1c_planner_a77cefeae3d7a58a96c74b66f6be22611}{planner\+::c\+Planner\+::\+Heuristic()}}.
\item Fixes calculation of consistency output\+: h(x) $<$= d(x,y) + h(y) with x as parent node and y as its successor.
\item In case of an inconsistent heuristic the boolean flag b\+Consistent\+Heuristic in the new member struct planner\+::t\+Result of c\+Planner\+Interface is set to false.
\item Adds g\+Tests that use a simplified map, including water and elevation transitions. The result struct is used to check the expected results.
\item Refactors visualizer
\begin{DoxyItemize}
\item Encapsulates the \mbox{\hyperlink{namespacevisualizer_ab4e649cd7413a51ac1ae4b31a2994c3a}{visualizer\+::write\+B\+M\+P()}} function including its lambda expression
\item Adds option (flag) what to draw
\begin{DoxyItemize}
\item locations such as start and goal passed as list of locations,
\item path,
\item N\+EW\+: display visited nodes in light red.
\end{DoxyItemize}
\item Adds option for pen size of the path.
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{Possible improvements}


\begin{DoxyItemize}
\item Use std\+::filesystem C++17 features to read and write elevation and overrides data.
\item std\+::chrono to time function calls.
\item std\+::array$<$int, size$>$ instead of std\+::vector for the optimized A\+Star version that allocates the closed set beforehand.
\end{DoxyItemize}

\subsection*{Lessons Learned}


\begin{DoxyItemize}
\item Use g\+Tests to spot bugs and wrong code changes early.
\item Use new C++ features such as smart pointers to avoid memory leaks. 
\end{DoxyItemize}