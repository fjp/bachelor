<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AID Coding Challenge - The Bachelor: AID Coding Challenge Solution version 0.0.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AID Coding Challenge - The Bachelor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AID Coding Challenge Solution version 0.0.0 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is my solution for the AID Bachelor Coding Challenge. For the problem description refer to the <a href="AID_Coding_Challenge.pdf">AID Coding Challenge.pdf</a>. The complete doxygen documentation can be found in the doc folder, see <a href="doc/html/index.html">index.html</a></p>
<h1>Result Preview</h1>
<p>Travelling from the Rover (ROVER_X, ROVER_Y) to the Bachelor (BACHELOR_X, BACHELOR_Y) will take 2094.51 island seconds (34.9085 island minutes or 0.581809 island hours) on the fastest path.</p>
<p>Travelling from the Bachelor (BACHELOR_X, BACHELOR_Y) to the Wedding (WEDDING_X, WEDDING_Y) will take 1283.17 island seconds (21.3862 island minutes or 0.356436 island hours) on the fastest path.</p>
<p>In total the Audi rover requires 3377.68 island seconds (56.2947 island minutes or 0.938245 island hours) on the fastest path. Details are explained at the end in section Results. To plot the path I added another path() function to the visualizer.cpp.</p>
<p>image html solution_rover_bachelor_wedding.jpg</p>
<div class="image">
<img src="solution_rover_bachelor_wedding.bmp" alt="solution_rover_bachelor_wedding.bmp"/>
<div class="caption">
solution rover bachelor wedding</div></div>
<div class="image">
<img src="doc/images/solution_rover_bachelor_wedding.bmp" alt="Solution Rover Bachelor Wedding" width="200"/>
</div>
<div class="image">
<img src="solution_rover_bachelor_wedding.jpg" alt="Solution Rover Bachelor Wedding" width="800"/>
</div>
<h1>Algorithm Choice</h1>
<p>To find the fastest route from a start to a goal location, I considered Gradient Fields, Dynamic Programming and Graph Search algorithms. I decided to use A* graph search because it is an informed search algorithm, which uses a heuristic function <img class="formulaInl" alt="$h(n)$" src="form_3.png"/> and relies on dynamic programming to find the shortest path. Compared to Dijkstra, which is an uninformed algorithm. The heuristic provides A* <br />
 with an estimate of the minimum cost from any node n to the goal.</p>
<p>Another reason against Gradient descent are the non-convex constraints imposed by the fjords. Gradient descent could easily fall into a lokal minimum and get stuck, which would require methods such as stochastic gradient descent.</p>
<h2>Cost Function</h2>
<p>The evaluation function <img class="formulaInl" alt="$f(n) = g(n) + h(n)$" src="form_0.png"/> describes the total cost of a node. It consists of the path cost <img class="formulaInl" alt="$g(n)$" src="form_1.png"/>, which describes how long it takes the rover to get to node <img class="formulaInl" alt="$n$" src="form_4.png"/> from its start location.</p>
<p>The path cost <img class="formulaInl" alt="$g(n)$" src="form_1.png"/> is calculated using the parent node's path cost <img class="formulaInl" alt="$g(parent)$" src="form_5.png"/> and the step cost <img class="formulaInl" alt="$c(n)$" src="form_6.png"/>, which is the cost of getting from the parent to the current node and that has to be positive. The step cost is described in the next section step-cost.</p>
<p>In this challenge the heuristic represents the time it takes the robot to move from a node to the goal. Because the robot can move in eight directions (straight and diagonal) I use an octile distance heuristic <img class="formulaInl" alt="$h(n)$" src="form_3.png"/>, implemented in cPlanner::UpdateHeuristic(). To get a consistent heuristic, I scaled it using the maximum gradient analyzing the elevation of the map and taking the slope into account. The consistency <img class="formulaInl" alt="$ h(n) &lt;= c(n,p) + h(p)$" src="form_7.png"/> is checked in <a class="el" href="classplanner_1_1c_planner.html#a1234d075676fcaa2c17b859d11b4638c" title="Check if the heuristic of node i_sNode is consistent. ">planner::cPlanner::HeuristicCheck()</a>. I exported the calculated heuristic values using <a class="el" href="classplanner_1_1c_planner.html#a1a4650050656545744796296a653d388" title="Output distance heuristic map to file, which is used to generate the Matlab plot. ...">planner::cPlanner::GenerateHeuristic()</a> in the google test TEST_F(cPlannerTest, heuristic) (see, test_system.cpp).</p>
<p>image html heuristic.jpg</p>
<div class="image">
<img src="heuristic.jpg" alt="Heuristic function plotted in Matlab" width="800"/>
</div>
<h2>Step Cost Model</h2>
<p>Another task was to model the speed of the rover when driving up or downhill. For this purpose I implemented a simple kinematic approach with an inclined plane to model the elevation of the terrain.</p>
<p>image html inclined.jpg</p>
<div class="image">
<img src="inclined.jpg" alt="inclined.jpg"/>
<div class="caption">
inclinded</div></div>
 <div class="image">
<img src="inclined.jpg" alt="Inclinde plane of a free body (Wikipedia)" width="500"/>
</div>
<p>The first step is to calculate the descent or ascent using the height difference between two locations, see <a class="el" href="classplanner_1_1c_planner.html#a16e8c156297fff49a6ba9b97073baffb" title="Updates the node argument with its path cost  with island seconds as its unit. ">planner::cPlanner::UpdateCost()</a>. In this method the pitch angle is calculated next, followed by computing the x or y component of the downhill-slope force using the gravitational force <img class="formulaInl" alt="$F_G$" src="form_8.png"/>. In the equation the friction is neglected.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_H &amp;= F_G \cdot sin\alpha \\ a_H &amp;= g \cdot sin\alpha \\ F_{H,x} &amp;= F_H \cdot cos\alpha \\ F_{H,x} = F_H \cdot cos\alpha \cdot sin\alpha = F_G \cdot \frac{1}{2} sin(2\alpha) \\ m \cdot a_x = m \cdot g \cdot \frac{1}{2} sin(2\alpha) \end{eqnarray*}" src="form_12.png"/>
</p>
<p>While the rover is moving up or downhill it is also moving in the x or y direction and the calculated acceleration <img class="formulaInl" alt="$a_x$" src="form_13.png"/> in x direction is acting on the rover. The same equation holds for the y-direction. To get the time it takes the rover to move up or downhill (regarding the two dimensional plane), the planar acceleration is used in the next kinematic equation, where <img class="formulaInl" alt="$\Delta s$" src="form_14.png"/> refers to the running length in either x or y direction.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \Delta s &amp;= v_0 \cdot t + \frac{1}{2} a_x t^2 \\ \Delta s &amp;= \frac{g}{4} \cdot sin(2\alpha) \cdot t^2 \\ t &amp;= \sqrt(\frac{4 \Delta s}{g \cdot sin(2\alpha}) \end{eqnarray*}" src="form_15.png"/>
</p>
<p>The start velocity is neglected in this formula but added to the final height time cost. The time it takes the rover to move one cell is given in the problem description (1 island second moving straight, and <img class="formulaInl" alt="$\sqrt 2$" src="form_17.png"/> moving diagonal). These step costs are implemented in <a class="el" href="classplanner_1_1c_planner.html#a16e8c156297fff49a6ba9b97073baffb" title="Updates the node argument with its path cost  with island seconds as its unit. ">planner::cPlanner::UpdateCost()</a>.</p>
<h1>Time and Space Complexity</h1>
<p>I avoid allocating two dimensional vectors of the image size. Instead I am using a std::priority_queue priority_queue.h (planner::cPlanner::m_poFrontier) and a std::map. The priority queue is sorted by the score value of the evaluation function <img class="formulaInl" alt="$f(n)$" src="form_2.png"/> and contains the frontier or border nodes. All expanded nodes are stored in an std::map inside the <a class="el" href="classplanner_1_1c_planner.html#a341e70531266f023ac9461d18979d1ef" title="AStar algorithm implementation. ">planner::cPlanner::AStar()</a> method together with their path costs <img class="formulaInl" alt="$g(n)$" src="form_1.png"/>.</p>
<p>The priority queue is suggested in all the literature and can access elements in linear time. With a step size of one the algorithm requires approximately 2 minutes to find the best path from rover to bachelor to the wedding. (MacBook Pro 3,3 GHz Intel Core i7, 16 GB 2133 MHz LPDDR3).</p>
<h1>Software Organization and Architecture</h1>
<p>The advantage of using interfaces is to get different implementations with different behavior but keep the public interface methods the same. I use two interfaces that have a reference to each other, <a class="el" href="classplanner_1_1c_rover_interface.html" title="Forward declaration of interface planner::cRoverInterface. ">planner::cRoverInterface</a> and <a class="el" href="classplanner_1_1c_planner_interface.html" title="cPlannerInterface is an abstract interface which can be implemented by concrete planner classes...">planner::cPlannerInterface</a>. The <a class="el" href="classplanner_1_1c_audi_rover.html" title="The concrete cAudiRover class implementation of the interface cRoverInterface&lt;size_t Direction&gt;...">planner::cAudiRover</a> implements <a class="el" href="classplanner_1_1c_rover_interface.html" title="Forward declaration of interface planner::cRoverInterface. ">planner::cRoverInterface</a> and acts as a factory, creating <a class="el" href="classplanner_1_1c_planner.html" title="Implements the planner interface cPlannerInterface&lt;size_t Directions&gt; with an action vector of size e...">planner::cPlanner</a> in planner::cRoverInterface::InitializePlanner(). To construct a Rover it requires the map data (<code>elevation.data</code> and</p><div class="fragment"><div class="line">overrides </div></div><!-- fragment --><p>). This data is used int the constructor of <a class="el" href="classplanner_1_1c_audi_rover.html" title="The concrete cAudiRover class implementation of the interface cRoverInterface&lt;size_t Direction&gt;...">planner::cAudiRover</a> to create a new map data structure of type tGraph. In the constructor the array of actions is initizlized which is flexible due to the template parameter of the base class planner::cRoverInterface&lt;size_t Directions&gt;. To start planning, the start and goal positions of the rover need to be set with planner::cRoverInterface::SetStart() and planner::cRoverInterface::SetGoal(). These methods provide the rover with location structs of type tLocation. After the initialization, a call to the method <a class="el" href="classplanner_1_1c_audi_rover.html#a09a9f9ff21d3b139db7c2990a5989674" title="The summon feature that the Audi rover provides. ">planner::cAudiRover::Summon()</a>, invokes the method <a class="el" href="classplanner_1_1c_audi_rover.html#a892dfcdf781ccdfe95f5af808f5a24ac" title="Initializes the reference to the planner which is located in the inherited interface. ">planner::cAudiRover::InitializePlanner()</a> which is part of the interface and used to create a new planner object. Finally the the interface method <a class="el" href="classplanner_1_1c_planner_interface.html#a7a06632a8c53906daf39611d9692ffa5" title="Virtual abstract method of the base interface, which must be implemented to perform a search algorith...">planner::cPlannerInterface::Plan()</a> is called. Possible parameters to <a class="el" href="classplanner_1_1c_audi_rover.html#a09a9f9ff21d3b139db7c2990a5989674" title="The summon feature that the Audi rover provides. ">planner::cAudiRover::Summon()</a> are the step size <a class="el" href="classplanner_1_1c_rover_interface.html#aea86540c3962e223de84f28ff067d788" title="Step size of the rover, varied to get to the goal quicker. ">planner::cRoverInterface::m_nStepSize</a> and its velocity <a class="el" href="classplanner_1_1c_rover_interface.html#a458f3e469a13cfc909e957678ddee753" title="Speed of the rover (always set to one, not tested). ">planner::cRoverInterface::m_nVelocity</a> (not tested testing).</p>
<p>During the the while loop of the AStar() method, debug messages are displayed every 100000 iterations in the following form:</p>
<div class="fragment"><div class="line">Max gradient 8</div><div class="line">Iteration 100000: Best node location (1406,338), </div><div class="line">     Evaluation function f(n): 423.181, step cost c(n): 0.654846, path cost g(n): 320.498, heuristic h(n): 102.683</div><div class="line">Iteration 200000: Best node location (1299,592), </div><div class="line">     Evaluation function f(n): 654.874, step cost c(n): 2.17358, path cost g(n): 573.159, heuristic h(n): 81.7151</div><div class="line">Iteration 300000: Best node location (1330,782), </div><div class="line">     Evaluation function f(n): 831.174, step cost c(n): 1, path cost g(n): 769.743, heuristic h(n): 61.4311</div><div class="line">Iteration 400000: Best node location (1565,567), </div><div class="line">     Evaluation function f(n): 917.657, step cost c(n): 1.41418, path cost g(n): 844.46, heuristic h(n): 73.1971</div></div><!-- fragment --><h2>CMake and File Structure</h2>
<p>I added a new planner library which gets linked by the main program Bachelor. To get the visualization working during the algorithm I placed the functions inside the main.cpp inside utilities.h and constants.h. The content of other files is documented in the Doxygen documentation. <br />
</p>
<h1>Coding Style</h1>
<p>For the variable naming conventions, I follow the <a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA C</a> standard.</p>
<h1>Testing</h1>
<p><b>Note</b> The tests are not completely finished because of the limited time.</p>
<p>I added google gTest version 1.8.0 to the zip file and created a test fixture <a class="el" href="classc_planner_test.html" title="The fixture for testing class cPlannerTest. ">cPlannerTest</a> in test_fixture.h. It is used to initialize the test by loading the evaluation.data and overrides.data files. Furthermore, the cAudiRover is initialized in the cPlannerTest::SetUp method.</p>
<p>As explained in software the default values for step size and velocity are set to one for both parameters. I tested with different step sizes to reach the goal faster, thereby verifying that the path and island seconds stay the same.</p>
<p>To get intermediate paths from the <a class="el" href="classplanner_1_1c_planner.html#a341e70531266f023ac9461d18979d1ef" title="AStar algorithm implementation. ">planner::cPlanner::AStar()</a> I used the provided <a class="el" href="namespacevisualizer.html#ab4e649cd7413a51ac1ae4b31a2994c3a">visualizer::writeBMP()</a> inside AStar(). This results in the following output:</p>
<h2>Results</h2>
<p>The total travelling time will take 3377.68 island seconds (56.2947 island minutes or 0.938245 island hours) on the fastest path. Hopefully this is enough for the Bachelor to get to his wedding on time.</p>
<p>image html solution_rover_bachelor_wedding.jpg</p>
<div class="image">
<img src="solution_rover_bachelor_wedding.jpg" alt="Fastest route from the rover to the bachelor and the wedding." width="800"/>
</div>
<p>The best path avoids high mountains and even gets close to see locations (bachelor to wedding) to find the fastest route.</p>
<div class="fragment"><div class="line">Max gradient: 8, Consistency factor: 10</div><div class="line">Iteration 100000: Best node location (334,1646), </div><div class="line">     Evaluation function f(n): 455.802, step cost c(n): 1.63855, path cost g(n): 259.565, heuristic h(n): 196.237</div><div class="line">Iteration 200000: Best node location (413,1697), </div><div class="line">     Evaluation function f(n): 582.518, step cost c(n): 1.63855, path cost g(n): 384.453, heuristic h(n): 198.065</div><div class="line">Iteration 300000: Best node location (495,1121), </div><div class="line">     Evaluation function f(n): 741.235, step cost c(n): 1.40002, path cost g(n): 604.166, heuristic h(n): 137.068</div><div class="line">Iteration 400000: Best node location (222,996), </div><div class="line">     Evaluation function f(n): 815.994, step cost c(n): 1.40002, path cost g(n): 670.159, heuristic h(n): 145.835</div><div class="line">Iteration 500000: Best node location (426,904), </div><div class="line">     Evaluation function f(n): 863.824, step cost c(n): 1.40002, path cost g(n): 742.2, heuristic h(n): 121.624</div><div class="line">Iteration 600000: Best node location (693,1925), </div><div class="line">     Evaluation function f(n): 923.431, step cost c(n): 1, path cost g(n): 714.164, heuristic h(n): 209.267</div><div class="line">Iteration 700000: Best node location (733,1933), </div><div class="line">     Evaluation function f(n): 1015.57, step cost c(n): 1, path cost g(n): 807.162, heuristic h(n): 208.41</div><div class="line">Iteration 800000: Best node location (877,1969), </div><div class="line">     Evaluation function f(n): 1095.94, step cost c(n): 1.40002, path cost g(n): 889.893, heuristic h(n): 206.046</div><div class="line">Iteration 900000: Best node location (747,840), </div><div class="line">     Evaluation function f(n): 1178.13, step cost c(n): 1.40002, path cost g(n): 1079.6, heuristic h(n): 98.5303</div><div class="line">Iteration 1000000: Best node location (868,1036), </div><div class="line">     Evaluation function f(n): 1290.78, step cost c(n): 2.15552, path cost g(n): 1177.67, heuristic h(n): 113.118</div><div class="line">Iteration 1100000: Best node location (837,623), </div><div class="line">     Evaluation function f(n): 1370.08, step cost c(n): 1, path cost g(n): 1296.97, heuristic h(n): 73.1023</div><div class="line">Iteration 1200000: Best node location (1023,906), </div><div class="line">     Evaluation function f(n): 1426.84, step cost c(n): 0.644409, path cost g(n): 1333.14, heuristic h(n): 93.698</div><div class="line">Iteration 1300000: Best node location (1060,512), </div><div class="line">     Evaluation function f(n): 1473.57, step cost c(n): 2.37537, path cost g(n): 1420.8, heuristic h(n): 52.7654</div><div class="line">Iteration 1400000: Best node location (819,1313), </div><div class="line">     Evaluation function f(n): 1518.79, step cost c(n): 1, path cost g(n): 1375.94, heuristic h(n): 142.848</div><div class="line">Iteration 1500000: Best node location (1141,719), </div><div class="line">     Evaluation function f(n): 1559.78, step cost c(n): 2.24475, path cost g(n): 1489.67, heuristic h(n): 70.1103</div><div class="line">Iteration 1600000: Best node location (943,329), </div><div class="line">     Evaluation function f(n): 1593.74, step cost c(n): 2.15552, path cost g(n): 1547.64, heuristic h(n): 46.1068</div><div class="line">Iteration 1700000: Best node location (936,273), </div><div class="line">     Evaluation function f(n): 1631.22, step cost c(n): 1, path cost g(n): 1586.74, heuristic h(n): 44.4872</div><div class="line">Iteration 1800000: Best node location (1326,1140), </div><div class="line">     Evaluation function f(n): 1669.75, step cost c(n): 2.15552, path cost g(n): 1563.3, heuristic h(n): 106.453</div><div class="line">Iteration 1900000: Best node location (1078,1322), </div><div class="line">     Evaluation function f(n): 1704.56, step cost c(n): 1, path cost g(n): 1571.54, heuristic h(n): 133.02</div><div class="line">Iteration 2000000: Best node location (1053,1445), </div><div class="line">     Evaluation function f(n): 1738.76, step cost c(n): 1.63855, path cost g(n): 1592.4, heuristic h(n): 146.355</div><div class="line">Iteration 2100000: Best node location (974,96), </div><div class="line">     Evaluation function f(n): 1773.15, step cost c(n): 1.40002, path cost g(n): 1739.8, heuristic h(n): 33.3556</div><div class="line">Iteration 2200000: Best node location (1342,1376), </div><div class="line">     Evaluation function f(n): 1817.68, step cost c(n): 0.644409, path cost g(n): 1686.97, heuristic h(n): 130.715</div><div class="line">Iteration 2300000: Best node location (1421,397), </div><div class="line">     Evaluation function f(n): 1890.01, step cost c(n): 1.63855, path cost g(n): 1853.92, heuristic h(n): 36.0877</div><div class="line">Iteration 2400000: Best node location (1519,1058), </div><div class="line">     Evaluation function f(n): 1950.36, step cost c(n): 1, path cost g(n): 1844.11, heuristic h(n): 106.247</div><div class="line">Iteration 2500000: Best node location (1398,265), </div><div class="line">     Evaluation function f(n): 2009.98, step cost c(n): 1.40002, path cost g(n): 1988.04, heuristic h(n): 21.935</div><div class="line">Iteration 2600000: Best node location (1379,182), </div><div class="line">     Evaluation function f(n): 2058.23, step cost c(n): 1, path cost g(n): 2045.38, heuristic h(n): 12.848</div><div class="line">Travelling will take 2094.51 island seconds (34.9085 island minutes or 0.581809 island hours) on the fastest path. </div><div class="line">Max gradient: 8, Consistency factor: 10</div><div class="line">Iteration 100000: Best node location (1416,333), </div><div class="line">     Evaluation function f(n): 422.513, step cost c(n): 0.64447, path cost g(n): 319.744, heuristic h(n): 102.769</div><div class="line">Iteration 200000: Best node location (1433,610), </div><div class="line">     Evaluation function f(n): 653.168, step cost c(n): 1.63855, path cost g(n): 578.803, heuristic h(n): 74.3647</div><div class="line">Iteration 300000: Best node location (1328,779), </div><div class="line">     Evaluation function f(n): 829.594, step cost c(n): 1.40002, path cost g(n): 767.78, heuristic h(n): 61.8139</div><div class="line">Iteration 400000: Best node location (1629,647), </div><div class="line">     Evaluation function f(n): 915.408, step cost c(n): 1.40002, path cost g(n): 848.555, heuristic h(n): 66.8539</div><div class="line">Iteration 500000: Best node location (1699,588), </div><div class="line">     Evaluation function f(n): 1000.31, step cost c(n): 1.40002, path cost g(n): 924.657, heuristic h(n): 75.6534</div><div class="line">Iteration 600000: Best node location (1512,1083), </div><div class="line">     Evaluation function f(n): 1079.1, step cost c(n): 1.40002, path cost g(n): 1055.3, heuristic h(n): 23.7924</div><div class="line">Iteration 700000: Best node location (1324,1112), </div><div class="line">     Evaluation function f(n): 1130.77, step cost c(n): 1, path cost g(n): 1097.93, heuristic h(n): 32.8387</div><div class="line">Iteration 800000: Best node location (1759,1086), </div><div class="line">     Evaluation function f(n): 1179.28, step cost c(n): 1.40002, path cost g(n): 1150.94, heuristic h(n): 28.3387</div><div class="line">Heuristic not consistent: 61.3867 &gt; 0.0733643 + 61.2453</div><div class="line">Heuristic not consistent: 97.5835 &gt; 0.0692139 + 97.4835</div><div class="line">Iteration 900000: Best node location (1166,1154), </div><div class="line">     Evaluation function f(n): 1222.19, step cost c(n): 1, path cost g(n): 1175.29, heuristic h(n): 46.899</div><div class="line">Iteration 1000000: Best node location (1222,1144), </div><div class="line">     Evaluation function f(n): 1262.49, step cost c(n): 1, path cost g(n): 1220.77, heuristic h(n): 41.7132</div><div class="line">Travelling will take 1283.17 island seconds (21.3862 island minutes or 0.356436 island hours) on the fastest path. </div><div class="line"></div><div class="line">Travelling will take 3377.68 island seconds (56.2947 island minutes or 0.938245 island hours) on the fastest path.  </div></div><!-- fragment --><p>Notice that the heuristic is not always consistent which requires more weight on the <img class="formulaInl" alt="$g$" src="form_18.png"/> score values. This can also be seen from the f score value which should stay the same because it is the sum of <img class="formulaInl" alt="$ g(n) + h(n) $" src="form_19.png"/>. <img class="formulaInl" alt="$g(n)$" src="form_1.png"/> should increase, while <img class="formulaInl" alt="$h(n)$" src="form_3.png"/> should decrease when moving to the goal. Tuning could be done in <a class="el" href="classplanner_1_1c_planner.html#a2e5a745f83f903662eff914d8beddb5e" title="Calculates a consistency factor to get a consistent heuristic h(n) &lt;= c(p,n) + h(p) ...">planner::cPlanner::CalculateConsistencyFactor()</a>, for example by lowering the gravitational force.</p>
<h2>Intermediate Paths</h2>
<p>As described above here is the image showing the indermediate path results that were explored by A*.</p>
<p>image html intermediate_rover_bachelor_wedding.bmp</p>
<div class="image">
<img src="intermediate_rover_bachelor_wedding.bmp" alt="Fastest route from the rover to the bachelor and the wedding, including intermediate path results." width="800"/>
</div>
<h1>References</h1>
<ul>
<li>Artificial Intelligence A Modern Approach Third Edition - Stuart Russel, Peter Norvig </li>
<li>Head First Design Patterns - Eric Freeman, Elisabeth Robson </li>
<li><a href="https://autonomous-driving.org/2018/08/15/so-you-want-to-be-a-self-driving-car-engineer/">https://autonomous-driving.org/2018/08/15/so-you-want-to-be-a-self-driving-car-engineer/</a> </li>
<li><a href="https://www.linkedin.com/pulse/software-quality-sami-vaaraniemi/">https://www.linkedin.com/pulse/software-quality-sami-vaaraniemi/</a> </li>
<li><a href="https://en.wikipedia.org/wiki/A">https://en.wikipedia.org/wiki/A</a>*_search_algorithm </li>
<li><a href="https://en.wikipedia.org/wiki/Consistent_heuristic">https://en.wikipedia.org/wiki/Consistent_heuristic</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Admissible_heuristic">https://en.wikipedia.org/wiki/Admissible_heuristic</a> </li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">https://www.redblobgames.com/pathfinding/a-star/introduction.html</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
