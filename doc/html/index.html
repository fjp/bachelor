<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AID Coding Challenge - The Bachelor: AID Coding Challenge Solution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AID Coding Challenge - The Bachelor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AID Coding Challenge Solution </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is my solution for the AID Bachelor Coding Challenge. For the problem description refer to the AID <a href="../../AID Coding Challenge.pdf">Coding Challenge.pdf</a>. The complete doxygen documentation can be found in the doc folder.</p>
<h1>Result</h1>
<p>Travelling from the Rover (ROVER_X, ROVER_Y) to the Bachelor (BACHELOR_X, BACHELOR_Y) will take 2094.51 island seconds (34.9085 island minutes or 0.581809 island hours) on the shortest path.</p>
<p>Travelling from the Bachelor (BACHELOR_X, BACHELOR_Y) to the Wedding (WEDDING_X, WEDDING_Y) will take 1283.17 island seconds (21.3862 island minutes or 0.356436 island hours) on the shortes path.</p>
<div class="image">
<img src="solution_rover_bachelor_wedding1.jpg" alt="Solution Rover Bachelor Wedding" width="500"/>
</div>
<h1>Algorithm Choice</h1>
<p>To find the fastest route from a start to a goal location, I considered Gradient Fields, Dynamic Programming and Graph Search. I decided for A* graph search algorithm, which uses Dynamic Programming to find the shortest path. Compared to Dijkstra it utilizes a heuristic <img class="formulaInl" alt="$h(n)$" src="form_3.png"/> which provides an estimate of the minimum cost from any node n to the goal.</p>
<p>Looking at the map, I deceided against Gradient because of the non convex constraints that are imposed by the fjords.</p>
<h2>Cost Function</h2>
<p>The evaluation function <img class="formulaInl" alt="$f(n) = g(n) + h(n)$" src="form_0.png"/> describes the total cost of a node. It consists of the path cost <img class="formulaInl" alt="$g(n)$" src="form_1.png"/>, which describes how long it takes the rover to get to node <img class="formulaInl" alt="$n$" src="form_4.png"/> from its start location.</p>
<p>The path cost <img class="formulaInl" alt="$g(n)$" src="form_1.png"/> is calculated using the parent node's path cost <img class="formulaInl" alt="$g(parent)$" src="form_5.png"/> and the step cost <img class="formulaInl" alt="$c(n)$" src="form_6.png"/>, which is the cost of getting from the parent to the current node. The step cost is described in the next section <a class="el" href="index.html#step-cost">step-cost</a>.</p>
<p>Because the robot can move in eight directions (straight and diagonal) I use an octile distance heuristic <img class="formulaInl" alt="$h(n)$" src="form_3.png"/>, implemented in cPlanner::UpdateHeuristic(). To get a consistent heuristic, I scaled it using the maximum gradient analyzing the elevation of the map and taking the slope into account. The consistency <img class="formulaInl" alt="$ h(n) &lt;= c(n,p) + h(p)$" src="form_7.png"/> is checked in planner::cPlanner::HeuristicCheck(). I exported the calculated heuristic values using <a class="el" href="classplanner_1_1c_planner.html#a1a4650050656545744796296a653d388" title="Generate distance heuristic vector member, which is inherited from the cPlannerInterface. ">planner::cPlanner::GenerateHeuristic()</a> in the google test TEST_F(cPlannerTest, heuristic) (see, test_system.cpp).</p>
<div class="image">
<img src="heuristic.jpg" alt="Heuristic function plotted in Matlab" width="500"/>
</div>
<h2>Step Cost Model</h2>
<h1><a class="anchor" id="step-cost"></a>
step-cost</h1>
<p>Another task was to model the speed of the rover when driving up or downhill. For this I implemented a simple kinematic approach with an inclined plane to model the elevation.</p>
<div class="image">
<img src="inclined.jpg" alt="inclined.jpg"/>
</div>
<div class="image">
<img src="inclined.jpg" alt="Inclinde plane of a free body (Wikipedia)" width="500"/>
</div>
<p>The first step is to calculate the descent or ascent using the height difference between two locations, see <a class="el" href="classplanner_1_1c_planner.html#a82e45fc2701e90d3fa9df72f475e455e" title="Updates the node argument with its path cost  with island seconds as its unit. ">planner::cPlanner::UpdateCost()</a>. In this method the pitch angle is calculated next, followed by computing the x component of the downhill-slope force using the gravitational force <img class="formulaInl" alt="$F_G$" src="form_8.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_H &amp;= F_G \cdot sin\alpha \rightarrow a = g \cdot sin\alpha \\ F_{H,x} &amp;= a \end{eqnarray*}" src="form_11.png"/>
</p>
<p>The rover’s speed is lower uphill. It’s part of the task to model in which way it becomes slower.  The rover’s speed gets higher when running downhill. It’s part of the task to model in which way it becomes faster.</p>
<h1>Time and Space Complexity</h1>
<p>I tried to avoid alocating two dimensional vectors of the image size. Instead I am using a std::priority_queue <a class="el" href="priority__queue_8h_source.html">priority_queue.h</a> (planner::cPlanner::m_poFrontier) and a std::map. The priority queue is sorted by the score value of the evaluation function <img class="formulaInl" alt="$f(n)$" src="form_2.png"/>.</p>
<h1>Software Organization and Architecture</h1>
<h1><a class="anchor" id="software"></a>
software</h1>
<p>The advantage of using interfaces is to get different implementations with different behavior but keep the public interface methods the same. I use two interfaces that reference each other, <a class="el" href="classplanner_1_1c_rover_interface.html" title="Forward declaration of interface planner::cRoverInterface. ">planner::cRoverInterface</a> and <a class="el" href="classplanner_1_1c_planner_interface.html" title="cPlannerInterface is an abstract interface which can be implemented by concrete planner classes...">planner::cPlannerInterface</a>. The <a class="el" href="classplanner_1_1c_audi_rover.html">planner::cAudiRover</a> implements <a class="el" href="classplanner_1_1c_rover_interface.html" title="Forward declaration of interface planner::cRoverInterface. ">planner::cRoverInterface</a> and acts as a factory, creating <a class="el" href="classplanner_1_1c_planner.html">planner::cPlanner</a> in planner::cRoverInterface::InitializePlanner(). To start planning the start and goal positions of the rover need to be set, planner::cRoverInterface::SetStart() and planner::cRoverInterface::SetGoal() passing a location struct of type tLocation. After the initialization, a call to the method <a class="el" href="classplanner_1_1c_audi_rover.html#a52c48afa0829f858c19d3ecf4940db21" title="The summon feature that the Audi rover provides. ">planner::cAudiRover::Summon()</a> invokes the planner::cPlannerInterface::Plan(). Possible parameters to <a class="el" href="classplanner_1_1c_audi_rover.html#a52c48afa0829f858c19d3ecf4940db21" title="The summon feature that the Audi rover provides. ">planner::cAudiRover::Summon()</a> are the step size planner::cRoverInterface::m_nStepSize and its velocity planner::cRoverInterface::m_nVelocity (not tested <a class="el" href="index.html#testing">testing</a>).</p>
<h1>Coding Style</h1>
<p>For the variable naming conventions, I follow the <a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA C</a> standard.</p>
<h1>Testing</h1>
<h1><a class="anchor" id="testing"></a>
testing</h1>
<p>Note The tests are not completely finished because of the limited time.</p>
<p>I added google gTest version 1.8.0 to the zip file and created a test fixture <a class="el" href="classc_planner_test.html" title="The fixture for testing class cPlannerTest. ">cPlannerTest</a> in <a class="el" href="test__fixture_8h_source.html">test_fixture.h</a>. It is used to initialize the test by loading the evaluation.data and overrides.data files. Furthermore, the cAudiRover is initialized in the <a class="el" href="classc_planner_test.html#a88ad8b0e63c66a9d94c7606aa67ef20d">cPlannerTest::SetUp</a> method.</p>
<p>As explained in <a class="el" href="index.html#software">software</a> the default values for step size and velocity are set to one for both parameters. I tested with different step sizes to reach the goal faster, thereby verifying that the path and island seconds stay the same.</p>
<p>To get intermediate paths from the planner::cPlanner::AStar() I used the provided visualizer::writeBMP() inside AStar(). This results in the following output:</p>
<h1>References</h1>
<ul>
<li>Artificial Intelligence A Modern Approach Third Edition - Stuart Russel, Peter Norvig </li>
<li>Head First Design Patterns - Eric Freeman, Elisabeth Robson </li>
<li><a href="https://autonomous-driving.org/2018/08/15/so-you-want-to-be-a-self-driving-car-engineer/">https://autonomous-driving.org/2018/08/15/so-you-want-to-be-a-self-driving-car-engineer/</a> </li>
<li><a href="https://www.linkedin.com/pulse/software-quality-sami-vaaraniemi/">https://www.linkedin.com/pulse/software-quality-sami-vaaraniemi/</a> </li>
<li><a href="https://en.wikipedia.org/wiki/A">https://en.wikipedia.org/wiki/A</a>*_search_algorithm </li>
<li><a href="https://en.wikipedia.org/wiki/Consistent_heuristic">https://en.wikipedia.org/wiki/Consistent_heuristic</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Admissible_heuristic">https://en.wikipedia.org/wiki/Admissible_heuristic</a> </li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">https://www.redblobgames.com/pathfinding/a-star/introduction.html</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
