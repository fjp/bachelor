<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AID Coding Challenge - The Bachelor: AID Coding Challenge Solution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AID Coding Challenge - The Bachelor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AID Coding Challenge Solution </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is my updated solution for the AID Bachelor Coding Challenge. The readme of the previous version can be found here. For the problem description refer to the <a href="AID_Coding_Challenge.pdf">AID Coding Challenge.pdf</a>. The complete doxygen documentation can be found in the doc folder, see <a href="doc/html/index.html">index.html</a></p>
<h2>Result</h2>
<div class="image">
<img src="doc/images/solution_v2_island_rover_bachelor_wedding.bmp" alt="Planning result with AStar() implementation." width="800"/>
</div>
<h2>Main New Features</h2>
<p>Beside the fixed bug of setting the diagonal cost to 1.4f instead of sqrt(2) I made the following changes to my solution.</p>
<h3>Simplified Motion Model</h3>
<p>I simplified the step cost model of the rover. Instead of the physical model, used previously, the rover now uses height costs that are percentage values of the current step cost, which are either <code>1</code> when moving straight or sqrt(2)` when moving diagonal. The percentage step cost (height cost) is added to the current step cost if the rover moves uphill and subtracted if it moves downhill. This height cost calculation takes place in <a class="el" href="classplanner_1_1c_planner.html#a9d57a0697bb0e4666f4fd45f77c4a1aa" title="Calculates the height cost which is added or subtracted from the step cost. ">planner::cPlanner::HeightCost</a>.</p>
<h3>Consistent Heuristic</h3>
<p>A consistent heuristic is ensured with the chosen step cost and height cost model. This is achieved by calculating a normalization factor <code>m_fConsistencyFactor = 1.f - static_cast&lt;double&gt;(m_nMaxGradient) / 255.0;</code>. I assume that <code>255</code> is the maximum that the rover can climb or fall, which is why I divide by 255.0. The normalization factor is then used to normalize the calculated octile heuristic value in <a class="el" href="classplanner_1_1c_planner.html#a77cefeae3d7a58a96c74b66f6be22611" title="Updates the heuristic value of the node located at tlocation i_sLocation. ">planner::cPlanner::Heuristic</a>. To check the consistency of the heuristic during A* I perform the check: h(x) &lt;= d(x,y) + h(y) with x as parent node and y as its successor. In case of an inconsistent heuristic the boolean flag bConsistentHeuristic in the new member struct planner::tResult of cPlannerInterface is set to false. This boolean flag is tested against in the gTests.</p>
<h3>Memory Leaks</h3>
<p>I analyzed my previous implementation using valgrind which showed memory leaks when creating child nodes in <a class="el" href="classplanner_1_1c_planner.html#adbffc6ce05119c940a09369d7e61554e" title="Generate a successor node state given a node i_sParent and action i_sAction. ">planner::cPlanner::Child</a>. Additionally because of not destructing the planner and audi rover objects correctly. To overcome these memory leaks I now use smart pointers which are a C++11 feature. The valgrind results for the planner and gTest project are shown in <a href="doc/valgrind.xml">doc/valgrind.xml</a> and <a href="valgrind_gtest.xml">valgrind_gtest.xml</a> respectively. See also the memory usage in the Memory Usage section below.</p>
<h3>Implementation Correctness</h3>
<p>To verify the correctness of my implemented AStar algorithm, I added two more implementations.</p><ol type="1">
<li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode">Wikipedia A* Pseudocode</a> implemented in class <a class="el" href="classplanner_1_1c_planner_wiki.html" title="Extends the planner class to implement A* from Wikipedia. ">planner::cPlannerWiki</a> which inherits from <a class="el" href="classplanner_1_1c_planner.html" title="Implements the planner interface cPlannerInterface&lt;size_t Directions&gt; with an action vector of size e...">planner::cPlanner</a>.</li>
<li><a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cplusplus">Red Blob Games A*</a> implemented in class <a class="el" href="classplanner_1_1c_planner_r_b_g.html" title="Extends the planner class to implement A* from Wikipedia. ">planner::cPlannerRBG</a> which inherits from <a class="el" href="classplanner_1_1c_planner.html" title="Implements the planner interface cPlannerInterface&lt;size_t Directions&gt; with an action vector of size e...">planner::cPlanner</a>.</li>
</ol>
<p>Both use less memory than my previous implementation, which can still be found in <a class="el" href="classplanner_1_1c_planner.html#a341e70531266f023ac9461d18979d1ef" title="AStar algorithm implementation. ">planner::cPlanner::AStar</a>. Less memory usage is achieved with other data structures. For example the node struct in Red Blob Games implementation uses less fields (see planner::tSimplifiedNode). Regarding the computation time, <a class="el" href="classplanner_1_1c_planner_wiki.html#aa673ebc2b1b43af3b13fb0c958c5f2e4">planner::cPlannerWiki::AStar</a> is the fastest implementation. Here preallocated vectors are used instead of a priority queue that needs to be updated in the other implementations.</p>
<h3>gTests using Simple Maps</h3>
<p>The mentioned implementations are used in new gTests which create and use simple maps to test if the different implementations yield the same results (regarding travelling time given in island seconds).</p>
<ol type="1">
<li>simple_map creates a 330x330 map with elevation 1 to check if the implementations find a path from the start to the goal location.</li>
</ol>
<div class="image">
<img src="doc/images/test/simple_map.bmp" alt="Simple Map." width="300"/>
</div>
<ol type="1">
<li>simple_map_with_water creates a 330x330 map with elevation 1 and water such that the greediness and therefore the heuristic is evaluated.</li>
</ol>
<div class="image">
<img src="doc/images/test/simple_map_with_water.bmp" alt="Simple Map with Water." width="300"/>
</div>
<p>All the implementations find a shortest but but the implementation from Wikipedia chooses the right side to pass the water obstacle.</p>
<ol type="1">
<li>simple_map_with_elevation is a 4x4 map with elevation 1 except the diagonal is set to 255. The rover needs to find a path between the left top corner (x,y)=(0,0) and the bottom right corner (x,y)=(3,3). This test is used to check the step cost, which is combination of height cost and direction cost. Furthermore, the consistency of the heuristic is evaluated.</li>
</ol>
<div class="image">
<img src="doc/images/test/simple_map_with_elevation.bmp" alt="Simple Map with Elevation." width="100"/>
</div>
<p>Additional test results can be seen in the image folder <a href="doc/images/test">doc/images/test</a>.</p>
<h2>C++11 Features</h2>
<p>Used <a href="https://github.com/AnthonyCalandra/modern-cpp-features">C++11 features</a>:</p><ul>
<li>smart pointer:<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>,</li>
<li><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr</a>,</li>
<li><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this</a>,</li>
<li><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this">shared_from_this()</a>,</li>
<li><a href="https://en.cppreference.com/w/cpp/language/nullptr">nullptr</a></li>
</ul>
</li>
<li><a href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expression</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/reference">Rvalue reference</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></li>
</ul>
<h2>Memory Usage</h2>
<p>The images below show the memory usage and runtime of the different A* implementations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">AStar  </th><th class="markdownTableHeadCenter">AStar Wikipedia  </th><th class="markdownTableHeadCenter">AStar Red Blob Games :----------------------&mdash;:   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div class="image">
<img src="doc/images/memory_usage_AStar.png" alt="AStar" width="250"/>
</div>
  </td><td class="markdownTableBodyCenter"><div class="image">
<img src="doc/images/memory_usage_AStar_Wiki.png" alt="AStarWiki" width="250"/>
</div>
  </td><td class="markdownTableBodyCenter"><div class="image">
<img src="doc/images/memory_usage_AStar_RBG.png" alt="AStarRedBlobGames" width="250"/>
</div>
   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">270.5 MB, 4:30 min  </td><td class="markdownTableBodyCenter">77.2 MB, 19.48 sec  </td><td class="markdownTableBodyCenter">208.1 MB, 3 min   </td></tr>
</table>
<h2>Class Design</h2>
<p>There exists a cyclic dependency between the rover interface and planner interface where the rover acts as a <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory</a> to create different planners.</p>
<h3>Complete Changelog</h3>
<ul>
<li>Fixes diagonal cost value: uses sqrt(2) for the diagonal cost instead of 1.4f.</li>
<li>Fixes memory leaks caused by dangling pointers, mainly in the Child() method of planner.cpp.<ul>
<li>Valgrind shows no memory leaks anymore with the use of smart pointers (C++11 feature)</li>
<li>Now using smart pointers for the nodes</li>
<li>Uses <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">shared_ptr</a>, <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr</a>, <a href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this</a> and <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this">shared_from_this()</a> for the cyclic dependency between rover interface and planner interface.</li>
<li>Use of smart pointers reduces memory consumption from approx 2 GB to 570 MB. This high memory is caused by creating child nodes while exploring new locations. Each node contains information that increase the memory used each time a new node is created.</li>
</ul>
</li>
<li>Uses double instead of float for the cost values to improve numerical inaccuracy because of diagonal step cost sqrt(2).</li>
<li>To verify the correctness of the current implementation this version adds two more implementations of A*, one from <a href="https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode">Wikipedia</a> and the other from <a href="https://www.redblobgames.com/pathfinding/a-star/implementation.html#cpp-astar">Red Blob Games</a>.</li>
<li>The new A* implementations use less memory</li>
<li>Simplifies step cost model of the rover: instead of the physical model the rover now uses height costs that are percentage values of the step cost. The percentage step cost (height cost) is added to the current step cost if the rover moves uphill and subtracted if it moves downhill. The height cost calculation takes place in <a class="el" href="classplanner_1_1c_planner.html#a9d57a0697bb0e4666f4fd45f77c4a1aa" title="Calculates the height cost which is added or subtracted from the step cost. ">planner::cPlanner::HeightCost()</a>.</li>
<li>Ensures consistent heuristic with the chosen step cost and height cost model. This is achieved by normalizing the calculated octile heuristic value in <a class="el" href="classplanner_1_1c_planner.html#a77cefeae3d7a58a96c74b66f6be22611" title="Updates the heuristic value of the node located at tlocation i_sLocation. ">planner::cPlanner::Heuristic()</a>.</li>
<li>Fixes calculation of consistency output: h(x) &lt;= d(x,y) + h(y) with x as parent node and y as its successor.</li>
<li>In case of an inconsistent heuristic the boolean flag bConsistentHeuristic in the new member struct planner::tResult of cPlannerInterface is set to false.</li>
<li>Adds gTests that use a simplified map, including water and elevation transitions. The result struct is used to check the expected results.</li>
<li>Refactors visualizer<ul>
<li>Encapsulates the <a class="el" href="namespacevisualizer.html#ab4e649cd7413a51ac1ae4b31a2994c3a">visualizer::writeBMP()</a> function including its lambda expression</li>
<li>Adds option (flag) what to draw<ul>
<li>locations such as start and goal passed as list of locations,</li>
<li>path,</li>
<li>NEW: display visited nodes in light red.</li>
</ul>
</li>
<li>Adds option for pen size of the path.</li>
</ul>
</li>
</ul>
<h2>Possible improvements</h2>
<ul>
<li>Use std::filesystem C++17 features to read and write elevation and overrides data.</li>
<li>std::chrono to time function calls.</li>
<li>std::array&lt;int, size&gt; instead of std::vector for the optimized AStar version that allocates the closed set beforehand. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
